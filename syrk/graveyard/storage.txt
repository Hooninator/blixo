def GEBP_4x4(N: size, A: [f32][4, 4] @ DRAM, B: [f32][4, 4] @ DRAM,
             C: [f32][4, 4] @ DRAM):
    assert N >= 1
    assert True and 4 == N
    assert stride(A, 1) == 1
    assert stride(C, 1) == 1
    for j in par(0, 4):
        for i in par(0, N):
            for k in par(0, 4):
                C[i, j] += A[k, i] * B[k, j]

def GEPP_syrk(A: [f32][16, 4] @ DRAM, B: [f32][16, 4] @ DRAM,
              C: [f32][16, 16] @ DRAM):
    assert 0
    assert stride(A, 1) == 1
    assert stride(C, 1) == 1
    for jo in par(0, 4):
        for ji in par(0, 4):
            for i in par(0, 4 * jo + ji + 1):
                for k in par(0, 4):
                    C[i, 4 * jo + ji] += A[k, i] * B[k, 4 * jo + ji]


^^^^^Important stuff up here

from __future__ import annotations
from exo import *
from exo.libs.memories import DRAM_STATIC
from exo.platforms.x86 import *
from exo.platforms.neon import *
from exo.syntax import *
import time
#import modular_sgemm

stime = time.time()
file = open("syrk.c", 'w+')

#microkernel sizes
M_r = 4
N_r = 4 #NOTE: This must be divisible by 4
#block sizes
M_c = 4 
K_c = 4
#Matrix sizes
M=16
N=16

@proc
def SYRK(M: size, K: size, A: f32[M, K], C: f32[M, K]):
    assert M >= 1
    assert K >= 1
    assert K==M
    assert stride(A, 1) == 1
    assert stride(C, 1) == 1

    for j in par(0, M):
        for i in par(0, j+1):
            for k in par(0, K):
                C[i, j] += A[k, i]*A[k, j]

syrk_window = (SYRK
                .rename('syrk_win')
                .set_window('A', True)
                .set_window('B', True)
                .set_window('C', True))

@proc
def SGEMM2(M: size, N: size, K: size, A: f32[M, K], B: f32[K, N], C: f32[M, N]):
    assert M >= 1
    assert N >= 1
    assert K >= 1
    assert stride(A, 1) == 1
    assert stride(B, 1) == 1
    assert stride(C, 1) == 1

    for i in par(0, N):
        for j in par(0, M):
            for k in par(0, K):
                C[j, i] += A[j, k] * B[k, i]

sgemm_window = (SGEMM2
                .rename('sgemm_win')
                .set_window('A', True)
                .set_window('B', True)
                .set_window('C', True))
#Microkernels

#Standard microkenel
microkernel = (sgemm_window
                .rename('microkernel')
                .partial_eval(N_r,M_r)
                .partial_eval(K=K_c)
                .simplify())
print(microkernel)
#file.write(microkernel.c_code_str())

neon_microkernel = (microkernel
                    .rename('neon_microkernel')
                    .reorder('j','i')
                    #Somehow, using this split command resizes C 
                    .split('j', 4, ['jo','ji'], perfect=True)
                    .par_to_seq('for k in _: _')
                    .stage_assn('C_reg', 'C[_] += _')
                    .lift_alloc('C_reg : _', n_lifts=4)
                    #double fission lifts both statements out and copies the loops they're wrapped in
                    .double_fission('C_reg[_] = C[_]', 'C_reg[_] += _', n_lifts=4)
                    .replace(neon_vld_4xf32, 'for ji in _: _ #0')
                    .replace(neon_vst_4xf32, 'for ji in _: _ #1')
                    .set_memory('C_reg', Neon4f)
                    )
print(neon_microkernel)

neon_microkernel = (neon_microkernel
                    .stage_expr('A_vec', 'A[_,_]', memory=Neon4f)
                    .stage_expr('B_vec', 'B[_,_]', memory=Neon4f)
                    #.replace(neon_vld_4xf32, 'for ji in _: _ #0')
                    #.replace(neon_vst_4xf32, 'for ii in _:_ #3')
                    .replace_all(neon_vld_4xf32)
                    .replace_all(neon_broadcast_4xf32)
                    .replace_all(neon_vfmadd_4xf32_4xf32)
                    #.lift_alloc('B_vec: _')
                    #.fission_after('neon_broadcast_4xf32(_)')
                    #lift_alloc and fission_after are used to split up bodies of loops
                    .lift_alloc('A_vec : _', n_lifts=2)
                    .fission_after('neon_broadcast_4xf32(_)', n_lifts=2)
                    .lift_alloc('B_vec : _', n_lifts=2)
                    .fission_after('neon_vld_4xf32(_) #1', n_lifts=2)
                    #.unroll('i') #NOTE: For some reason, trying to unroll i causes a recursion depth exception
                    #.unroll('k') NOTE: This leads to no performance improvement, and it also makes generation take a long time
                    .unroll('io')
                    .simplify())
print(neon_microkernel)
"""

Basic idea
    - Generate GEBPs for all the partitioned loop bounds in GEPP
    - Generate GEPPs for all the possible values of i..j+1
    - Figure out diagonal kernel

We need to modify GEBP so it accepts and operates on progressively smaller panels of C.
This means calling partial_eval() for different values of N, and then packing B to be the appropriate size,
then calling the appropriate GEBP kernel

So now, what GEBP kernels do we need to generate?
We need one for each possible length of C_panel.
What are those possible lengths?
From 1 to N. Obviously the height of C_panel is just K_blk. Okay that should work.

So how do we have to modify GEPP?
It needs to iterate from 0 to N (M==N so j loop should work for this) and call the proper GEBP
for each iteration. BUT keep in mind the length of C_panel won't increase by 1 for each iteration.
It will instead increase by K_c at each iteration.
So, we just need to split the j loop by K_c, call specialize, and pattern match with each of the GEBP kernels.

Now, to figure out this diagonal nonsense. 
I think we could use partition_loop to partition one of the loops such that the first part handles GEBP and the second part does this diagonal thing.
What should the kernel do lol -- goto and van de geijn are like "oh its a SPECIAL kernel"
The kernel should accept a K_c*K_c block, and the upper half of this block will be all zeros. So it's just GEBP modified to only deal with the lower triangle of C.

def GEBP_MKc(N: size, A: [f32][4, 4] @ DRAM, B: [f32][4, N] @ DRAM,
             C: [f32][4, N] @ DRAM):
    assert 4 >= 1
    assert N >= 1
    assert 4 >= 1
    assert stride(A, 1) == 1
    assert stride(B, 1) == 1
    assert stride(C, 1) == 1
    for i in par(0, 4):
        for j in par(0, N):
            for k in par(0, 4):
                C[i, j] += A[i, k] * B[k, j]
"""

#GEBP Kernel Generation
def generate_GEBP_kernels(lda):
    simple_gebp_kernels = {}
    scheduled_gebp_kernels = {}

    for i in range(K_c, lda, K_c):
        simple_gebp_kernels[i//K_c] = (sgemm_window
        .partial_eval(M=M_c)
        .partial_eval(K=K_c)
        .partial_eval(N=i)
        .rename(f'GEBP_{K_c}x{i}')
        .simplify())
        scheduled_gebp_kernels[i//K_c] = (simple_gebp_kernels[i//K_c]
                                    #Tile the block of A and the panel of B
                                    .split('i', N_r, ['io', 'ii'], tail='cut_and_guard')
                                    .split('j', M_r, ['jo', 'ji'], tail='cut_and_guard')
                                    #Handle edge case
                                    .fission_after('for io in _: _', n_lifts=2)
                                    .fission_after('for jo in _: _', n_lifts=2)
                                    #reorder so loop ordering is same as microkernel
                                    .reorder('ii','jo')
                                    .replace_all(microkernel)
                                    .call_eqv(neon_microkernel, 'microkernel(_)')
                                    #.replace_all(microkernel_edge_gebp) TODO: Handle edge cases later
                                    #.replace_all(microkernel_edge_gebp_simple)
                                    #.call_eqv(microkernel_edge_gebp_scheduled, 'microkernel_edge_gebp(_)')
                                    .simplify()
                                    )
        print(scheduled_gebp_kernels[i//K_c])
    return (simple_gebp_kernels, scheduled_gebp_kernels)








# Generate GEPP
GEPP_syrk_intermediate = (sgemm_window
            .rename("GEPP_syrk_intermediate")
            .reorder('i', 'j')
            .partial_eval(K=K_c)
            .partial_eval(N=N)
            .simplify()
)


print(GEPP_syrk_intermediate)

GEPP_syrk = (GEPP_syrk_intermediate
            .rename("GEPP_syrk")
            .split('j', K_c, ['jo', 'ji'], tail='cut_and_guard')
            .specialize('for ji in _ : _ #0', [f'{K_c}*jo=={i}' for i in range(0, N, K_c)])
            .repeat(Procedure.reorder, 'ji', 'i')
            .simplify()
            )
#print(GEPP_syrk)

# Partition each loop
temp = 1
for i in range(1, (K_c*2)-1, 2):
    GEPP_syrk = (GEPP_syrk.partition_loop(f'i #{i}', temp*K_c))
    temp+=1

# Substitute GEBP Kernels 
simple_gebp_kernels, scheduled_gebp_kernels = generate_GEBP_kernels(N)
for i in range(1, N//K_c):
    GEPP_syrk = GEPP_syrk.replace(simple_gebp_kernels[i], f'for i in _:_ #{i}')
    GEPP_syrk = GEPP_syrk.call_eqv(scheduled_gebp_kernels[i], f"GEBP_{K_c}x{i*K_c}(_)")

print(GEPP_syrk)

exo_syrk = (syrk_window
            .rename("exo_syrk")
            .reorder('i', 'k')
              .reorder('j', 'k')
              .split('k', K_c, ['ki', 'ko'], tail='cut_and_guard')
              .fission_after('for ko in _: _ ', n_lifts=2)
              .reorder('ko', 'j')
              .reorder('ko', 'i')
            #.reorder('k', 'jo')
            #.reorder('ko', 'i')
            #.split('j', K_c, ['jo', 'ji'], tail='cut_and_guard')
            #.specialize('for i in _:_ #0', [f'{K_c} * ji + jo + 1=={i}' for i in range(K_c * M//4 + K_c + 1)])
            .replace_all(GEPP_syrk_intermediate)
            #.partial_eval(N=N)
            #.simplify()
            )
print(exo_syrk)
file.write(exo_syrk.c_code_str())
file.close()