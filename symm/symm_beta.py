from __future__ import annotations
from cmath import log
import sys
from concurrent.futures import process
from exo import *
from exo.libs.memories import DRAM_STATIC
from exo.platforms.x86 import *
from exo.platforms.neon import *
from exo.syntax import *
import modular_sgemm

file = open("symm_2.c", 'w+')

#microkernel sizes
M_r = 4
N_r = 4 #NOTE: This must be divisible by 4, fix that at some point
#block sizes
M_c = 8
K_c = 8
#Matrix sizes
M=16
N=16
K=16


@proc
def SYMM(M: size, N: size, K: size, A: f32[M, K], B: f32[K, N], C: f32[M, N], N_ITERS: size):
    assert M >= 1
    assert N >= 1
    assert K >= 1
    assert K > K_c
    assert stride(A, 1) == 1
    assert stride(B, 1) == 1
    assert stride(C, 1) == 1

    #A_panel : f32[M, K_c]
    
    #A_11 : f32[M_c, K_c]
    #A_10 : f32[M_c, K_c]
    #A_21 : f32[M_c*2, K_c]

    #Copy A_21 and A_11 in
    #for j in par(M_c, M_c+M_c):
    #    for j in par(0, K_c*2):


    #for n_iter in seq(0, N_ITERS):

        #modular_sgemm.GEPP(M, N, A[0:M, 0:8], B[0:8, 0:N], C[0:M, 0:N])
    for n_iter in seq(0, N_ITERS):
        for i in par(0, M):
            for j in par(0, N):
                for k in par(0, K_c):
                    C[i, j] += A[i, k] * B[k, j]
                        



#Block
SYMM_BLK = (SYMM
            .rename("SYMM_BLK")
            .set_window('A', True)
            .set_window('B', True)
            .set_window('C', True))

#Substitute GEPP
n_iters = 1+((N-2*M_c)//M_c)
print(f"n_iters: {n_iters}")


SYMM_BLK = (SYMM_BLK
            .partial_eval(N_ITERS = n_iters)
            #Set up A_panel
            .stage_expr('A_panel', 'A[_, _]', memory=DRAM_STATIC)
            .lift_alloc('A_panel : _', n_lifts=2)
            .fission_after('C[_] += _ ', n_lifts=2)
            
            #Somehow mess with the A_panel loop so it writes the proper indices 
            #NOTE: To make this work, you need to do the specialize thingy, but with n_iter and multipky first parititon K_c by each value in 0..n_iters
            #NOTE: Would really be nice if I could somehow refer to the loop variable n_iter in the first partition_loop
            .partial_eval(M=M)
            .partition_loop('i #0', K_c)
            .partition_loop('i #1', K_c)
            .simplify()
            )
print(SYMM_BLK)
"""
SYMM_BLK = (SYMM_BLK
            .reorder('j', 'k')
            .reorder('i', 'k')
            .split('k', n_iters, ['n_iters', 'k'], tail='cut_and_guard')
            #.reorder('k', 'n_iters')
            .reorder('k', 'i')
            .reorder('k', 'j')
            .replace_all(modular_sgemm.GEPP_MKc)
            )
"""

#This procedure is generated by the above code -- I'm manually editing it here
#okay shit the problem with this is that we need one of these for each loop iteration so manually editing is impsosible for large
@proc 
def _SYMM_BLK(N: size, K: size, A: [f32][M, K] @ DRAM, B: [f32][K, N] @ DRAM,
             C: [f32][M, N] @ DRAM):
    assert N >= 1
    assert K >= 1
    assert K > 4
    assert K % K_c == 0
    assert M % M_c == 0
    assert K > K_c*n_iters
    assert M > M_c*n_iters
    assert stride(A, 1) == 1
    assert stride(B, 1) == 1
    assert stride(C, 1) == 1
    for n_iter in seq(0, n_iters):
        A_panel: R[M, K_c] @ DRAM_STATIC

        #This loop handles the transposed A_10 block
        for i in par(0, K_c + (n_iter * K_c)):
            for k in par(0, M_c):
                A_panel[i, k] = A[(k + n_iter * M_c + M_c), i]
        
        #This loop handles the A_11 block 
        for i in par(0, M_c):
            for k in par(0, K_c):
                A_panel[i + M_c, k] = A[(i + n_iter * M_c + M_c), (k + n_iter * K_c + K_c)]
        
        #This loop handles the A_21 block
        for i in par(0, (M - M_c * 2) - (n_iter * M_c)):
            for k in par(0, K_c):
                A_panel[i + M_c*2, k] = A[(i + M_c * 2 + M_c * n_iter), (k + n_iter * K_c + K_c)]

        #modular_sgemm.GEPP(M, N, A_panel[0:M, 0:K_c], B[0:K_c, 0:N], C[0:M, 0:N])
        for i in par(0, M):
            for j in par(0, N):
                for k in par(0, K_c):
                    C[i, j] += A_panel[i, k] * B[k, j]

_SYMM_BLK = (_SYMM_BLK.simplify())


#Now, we partition B and C
_SYMM_BLK = (_SYMM_BLK
                .partial_eval(N=N) #Do this otherwise DRAM_STATIC complains'
                .stage_expr('B_panel', 'B[_, _]', memory=DRAM_STATIC)
                .lift_alloc('B_panel : _', n_lifts=2)
                .fission_after('C[_] += _ ', n_lifts=2)
                .rearrange_dim('B_panel : _', [1, 0])
                .simplify()
                #.replace_all(modular_sgemm.GEPP_MKc)
                #.call_eqv(modular_sgemm.GEPP, 'GEPP_MKc(_)')
                 )
print(_SYMM_BLK)

@proc
def __SYMM_BLK(K: size, A: f32[M, K] @ DRAM, B: f32[K, N] @ DRAM,
              C: f32[M, N] @ DRAM):
    assert N >= 1
    assert K >= 1
    assert K > 4
    assert K % K_c == 0
    assert M % M_c == 0
    assert K >= K_c*(n_iters+1)
    assert M >= M_c*(n_iters+1)
    assert stride(A, 1) == 1
    assert stride(B, 1) == 1
    assert stride(C, 1) == 1
    
    for n_iter in seq(0, n_iters+1):
        A_panel: R[M, K_c] @ DRAM_STATIC
        
        #This loop handles the transposed A_10 block
        for i in par(0, (n_iter * K_c)):
            for k in par(0, M_c):
                A_panel[i, k] = A[(k + n_iter * M_c), i]
        
        #This loop handles the A_11 block 
        for i in par(0, M_c):
            for k in par(0, K_c):
                A_panel[(n_iter * K_c + i), k] = A[(i + n_iter * M_c), (k + n_iter * K_c)]
        
        #This loop handles the A_21 block
        for i in par(0, (M - M_c - (n_iter * M_c))):
            for k in par(0, K_c):
                A_panel[(M_c + n_iter * M_c + i), k] = A[(i + M_c * n_iter + M_c), (k + n_iter * K_c)]

        #This loop creates the B panel
        B_panel: R[K_c, N] @ DRAM_STATIC
        for j in par(0, N):
            for k in par(0, K_c):
                B_panel[k, j] = B[(k + (K_c * n_iter)), j]

        #Call GEPP
        modular_sgemm.GEPP(M, N, A_panel[0:M, 0:K_c], B_panel[0:K_c, 0:N], C[0:M, 0:N])

print(__SYMM_BLK)

file.write(__SYMM_BLK.c_code_str())